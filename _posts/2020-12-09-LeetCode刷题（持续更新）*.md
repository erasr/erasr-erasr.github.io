---
layout:     post
title:      LeetCode刷题（持续更新）
subtitle:   刷题记录
date:       2020-12-09
author:     V
header-img: img/post-bg-2015.jpg
catalog: true
tags:
    - 算法 LeetCode
---

***右侧有目录→***

# 一、数据结构相关

### 1.链表

##### [1).找出两个链表的交点（简单）](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/description/)

该题要求时间复杂度为O(N)。如果想用两个指针分别指向两个链表，然后遍历求解，这样就需要两层循环，显然不符合时间复杂度O(N)的要求

对于正确解法的理解可以看下这张图⬇️

![](/img/leetcoding/1_1_1_1.jpeg)
    
```python
#正解

class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:
        ha, hb = headA, headB
        while ha != hb:
            ha = ha.next if ha else headB
            hb = hb.next if hb else headA
        return ha
```

*另外补充下，如果只是判断两个链表是不是有共同结点，可以这么做

1. 将两个链表首尾相连，然后判断后一个链表是不是循环链表
2. 直接比较两个链表的尾结点相不相等

![](/img/leetcoding/1_1_1_2.jpeg)

---

##### [2).链表反转（简单）](https://leetcode-cn.com/problems/reverse-linked-list/description/)

这里要用到两个指针，一个指向当前结点，一个指向新链表的头结点（当前结点的上一个结点）

![](/img/leetcoding/1_1_2_1.jpeg)

```python
#正解

class Solution:
    def reverseList(self, head: ListNode) -> ListNode:
        pre = None
        cur = head
        while cur:
            temp = cur.next 
            cur.next = pre
            pre = cur
            cur = temp
        return pre
```

*另外可以用递归的方式反转链表：

```python
#递归

class Solution:
    def reverseList(self, head: ListNode) -> ListNode:
        if head is None or head.next is None:
            return head

        p = self.reverseList(head.next)
        head.next.next = head
        head.next = None
        return p
```

---

##### [3).合并两个有序链表（简单）](https://leetcode-cn.com/problems/merge-two-sorted-lists/description/)

下面是直接合并两个链表的操作，没有用到递归。

大体思路如下：

若两个链表都非空，则从最左边开始比较两个链表的结点值。谁小，要谁。并将小值对应的链表的指针后移一位。如此往复。直至其中一个链表的结点全部走完。最后，只需要将没走完的链表接在新链表的尾巴上就OK了。


```python
#正解

class Solution:
    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode:
        head = ListNode(None)
        ret = head #ret用来记录新链表的头结点，并将其的next返回
        while l1 and l2:
            if l1.val > l2.val:
                head.next = ListNode(l2.val)
                head = head.next
                l2 = l2.next
            else:
                head.next = ListNode(l1.val)
                head = head.next
                l1 = l1.next

        if l1:
            head.next = l1
        if l2:
            head.next = l2
        return ret.next
```

下面是递归实现的代码：

```python
# 递归解法

class Solution:
    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode:
        if not l1:
            return l2
        if not l2:
            return l1
        if l1.val < l2.val:
            l1.next = self.mergeTwoLists(l1.next, l2)
            return l1
        else:
            l2.next = self.mergeTwoLists(l1, l2.next)
            return l2
```

递归的话，不要去纠结细节。要有**宏观**上的感觉。

递归我们只需要关注两件事 1.递归终止的条件是什么 2.递归体内部要做的是什么

比如这题，宏观上的递归思路就是：

递归终止的条件是什么？

终止条件就是，当其中之一的链表变为空时，则return。

递归体内部做的是是什么？

递归体内部做的是，比较两个链表当前结点值的大小。小的一方，则后边跟上递归调用。

递归调用传参该怎么传？

传参只需要将小的结点除去就OK了。用「.next」

我画了个图，便于理解。

![](/img/leetcoding/1_1_3_1.jpeg)

---

##### [4).删除链表的倒数第N个节点（中等）](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)

直接写的思路是：

首先求出链表的长度。然后再从头遍历至待删除结点，将其删除即可。

这里有几个特殊情况需要注意：1）当`length == n`时，这时只需要将`head.next`返回就可以了。其中包括`length == 1`这种情况；2）当`n == 1`时，将最后一个结点置空即可。


```python
#正解

class Solution:
    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:
        if head is None:
            return None

        cur = head
        length = 0
        while cur:
            length += 1
            cur = cur.next

        if length == n:
            return head.next

        cur = head
        l = 1
        while l < length - n:
            l += 1
            cur = cur.next

        if n == 1:
            cur.next = None
        else:
            cur.next = cur.next.next
        return head
```

进阶版是用**一趟扫描**实现。

如果用一趟扫描，我们面对的问题是什么呢？我们不知道链表的长度，所以不知道该删除的结点到底在哪。

那么怎样才能找到那个待删除的结点呢？题目中给出了`n`的值，那可以从`n`的值作为突破点。

首先需要一个`fast`指针，让它先跑`n`步。因为`fast = head`，所以等`fast`跑完`n`步时，其实是指向第`n+1`个结点。此时，若`fast`指向空结点，那说明这满足`length == n`这种情况，所以要`return head.next`。

![](/img/leetcoding/1_1_4_1.jpeg)

下面还需要一个`slow`结点，指向链表的头结点。因为这时`fast`已经跑出去`n+1`步了，所以只需让`fast`跑到链表的尾结点即可，这时`slow`指向的下一个结点就是待删除结点。

![](/img/leetcoding/1_1_4_2.jpeg)

```python
#进阶版

class Solution:
    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:
        fast = head
        while n > 0:
            fast = fast.next
            n -= 1

        if fast is None:
            return head.next # length == n 的情况

        slow = head
        while fast.next is not None:
            fast = fast.next
            slow = slow.next

        slow.next = slow.next.next

        return head
```

# 二、算法思想

还没开始

# 三、感谢[GitHub@CyC2018](https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E7%9B%AE%E5%BD%95.md)提供的刷题目录