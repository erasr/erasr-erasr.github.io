---
layout:     post
title:      刷题「栈和队列」相关
subtitle:   LeetCode刷题系列
date:       2020-10-01
author:     V
header-img: img/post-bg-github-cup.jpg
catalog: true
tags:
    - LeetCode刷题之数据结构系列
---

##### [1).用栈实现队列（简单）](https://leetcode-cn.com/problems/implement-queue-using-stacks/description/)

栈的特点是「先进后出」。队列的特点是「先进先出」。现在要求使用*后进先出*的栈实现一个*先进先出*的队列。

方法一：

我们可以用两个栈来实现。其中一个栈用来存储数据，我们称为「数据栈」，另外一个栈用来辅助将数据倒序`push`进第一个栈的，我们称为「辅助栈」。因为，这样可以让数据栈的数据保持新来的数一直在栈顶，这样可以实现「先进先出」。

画图如下：

![](/img/leetcoding/stackAndQueue/1_1.jpeg)

```python
class MyQueue:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        # 数据栈
        self.stack1 = []
        # 辅助栈
        self.stack2 = []
        # 数据的个数，用来指向栈顶元素
        self.size = 0


    def push(self, x: int) -> None:
        """
        Push element x to the back of queue.
        """
        # 先把数据栈里的数据放到辅助栈
        while self.stack1:
            self.stack2.append(self.stack1.pop())

        # 在数据栈中压入新来的数
        self.stack2.append(x)

        # 再将辅助栈的数据放回数据栈
        while self.stack2:
            self.stack1.append(self.stack2.pop())

        self.size += 1


    def pop(self) -> int:
        """
        Removes the element from in front of queue and returns that element.
        """
        self.size -= 1
        return self.stack1.pop()

    def peek(self) -> int:
        """
        Get the front element.
        """
        if self.stack1 != []:
            return self.stack1[self.size - 1]
        else:
            return None

    def empty(self) -> bool:
        """
        Returns whether the queue is empty.
        """
        return self.stack1 == []
```

复杂度分析：

时间复杂度：入队O(n)，出队O(1)，取队首元素O(1)，判空O(1)。

空间复杂度：入队O(n)，出队O(1)，取队首元素O(1)，判空O(1)。

方法二：

还是使用两个栈，只不过现在两个栈中都存放数据。两个栈的区别是，只有当出栈`pop`时，才把`stack1`的数据放到`stack2`中，然后`return stack2.pop()`。为了实现`peek`方法，同时还要维护一个`front`变量，使其一直指向`stack1`的栈底元素，因为只是peek一下，所以不用像`pop`那样将`stack1`的数据移动到`stack2`中，这样可在O(1)的复杂度实现`peek`方法。

画图如下：

![](/img/leetcoding/stackAndQueue/1_2.jpeg)

```python
class MyQueue:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.stack1 = []
        self.stack2 = []
        self.sizeOfStack2 = 0
        self.front = None


    def push(self, x: int) -> None:
        """
        Push element x to the back of queue.
        """
        # 如果stack1空，则
        if not self.stack1:
            self.front = x
        self.stack1.append(x)


    def pop(self) -> int:
        """
        Removes the element from in front of queue and returns that element.
        """
        if not self.stack2:
            while self.stack1:
                self.stack2.append(self.stack1.pop())
                self.sizeOfStack2 += 1
        self.sizeOfStack2 -= 1
        return self.stack2.pop()


    def peek(self) -> int:
        """
        Get the front element.
        """
        # 如果stack2不为空，就直接返回其栈顶元素
        if self.stack2:
            return self.stack2[self.sizeOfStack2 - 1]
        # 如果为空，因为只是peek一下，所以不用将stack1的数据转移到stack2中，直接返回维护好的front即可。
        else:
            return self.front


    def empty(self) -> bool:
        """
        Returns whether the queue is empty.
        """
        return self.stack1 == [] and self.stack2 == []
```

复杂度分析：

时间复杂度：入队O(1)，出队均摊复杂度O(1)，取队首元素O(1)，判空O(1)。

空间复杂度：入队O(n)，出队O(1)，取队首元素O(1)，判空O(1)。

---

##### [2).用队列实现栈（简单）](https://leetcode-cn.com/problems/implement-stack-using-queues/description/)



---

##### [3).最小值栈（简单）](https://leetcode-cn.com/problems/min-stack/description/)

---

##### [4).用栈实现括号匹配（简单）](https://leetcode-cn.com/problems/valid-parentheses/description/)

---

##### [5).数组中元素与下一个比它大的元素之间的距离（中等）](https://leetcode-cn.com/problems/daily-temperatures/description/)

---

##### [6).循环数组中比当前元素大的下一个元素（中等）](https://leetcode-cn.com/problems/next-greater-element-ii/description/)